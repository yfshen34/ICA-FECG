% function [y, w] = cfICA(X, refer)
% Constrained Fast ICA for extracting one source signal using the reference signal.
%
% Command:
%   [y, w] = cICA(X, ref, threshold, w0, learningRate, mu10, lambda0, gamma, maxIter, OverValue)£»
%
% Parameters:
%            y --- extracted source signal, according to the given optimal time delay.
%            w --- corresponding weight vector, that is, y=w'*X.
%            X --- prewhitened observed mixed signals. Each row is a mixed signal.
%          ref --- reference signal, which can be generated by function genRectangleRef
%                  and genPulseRef
%    threshold --- the closeness of the desired signal and the reference signal is less than
%                  or equal to the threshold, i.e., closeness(y,ref) - threshold <= 0
%           w0 --- the initial weight vector
% learningRate --- learning rate of the weight w
%          mu10 --- the Lagrange mu1ltiplier for constraint g(w)
%      lambda0 --- the Lagrange mu1ltiplier for constraint h(w)
%        gamma --- the scalar penalty parameter
%  OverValue --- stopping criterion, say, 0.0001. When the changed value
%                of weighted vector is less than it, then the algorithm stops
%    maxIter --- maximu1m iterations for estimating each independent component
%
% See also:
%    genPulseRef     genRectangleRef     cICAdemo
%
% Reference:
%    [1] Wei Lu, Jagath C. Rajapakse: ICA with reference. ICA 2001
%    [2] Zhi-Lin Zhang, Morphologically Constrained ICA for Extracting Weak Temporally
%        Correlated Signals, Neurocomputing 71(7-9) (2008) 1669-1679
%
% Author: Zhilin Zhang
%         z4zhang@ucsd.edu
%
% version: 1.0     Date: Dec.14,2008
%
clc
clear
close all
load('1period.mat');
X=xw;
refer=refer(2,:);

ref=refer/sqrt(mean(refer.^2));
fprintf('Starting cICA for extracting the desired source signal ..\n');
[ICnum, IClen]=size(X);

w=mean(X(:,ref>0),2);
w=w/norm(w);
oldw = w;

threshold1 = 1; 
threshold2 = 0.5; 

gamma1=1e1;
gamma2=1e1;

mu1 = 0;
mu2 = 0;

OverValue=0.00001;
maxIter = 200;

flag = 1;
loop = 1;

% compute the autocorrelation matrix Rxx
% Rxx = X(:,[1:end]) * X(:,[1:end])' / IClen;
thr1 = threshold1 ;
thr2 = threshold2 ;

% output at current iteration
    y = w' * X;

figure
while (flag == 1)
    % Update ¦Ã.
    gamma1=gamma1*1.02;
    gamma2=gamma2*1.02;
    
  
    % calculate the first order deviation of the Lagarange function
%     std_y = std(y);                          % standard deviation
%     v_Gaus = normrnd(0, std_y, 1, IClen);    % Gaussian signal with the same mean and variance
%     rou = mean( log(cosh(y)) - log(cosh(v_Gaus)) );
    %     L1 = sign(rou) * ( X * tanh(y)')/IClen - mu1 * ( X * (y - ref)')/IClen ...
    %         - lambda * ( X * y')/IClen;
    
    
    % related to the second order deviation of the Lagarange function
    %     Sw = sign(rou) * mean(1-tanh(y).^2) - mu1 - lambda;
    
    % update of the weight vector
    %     w = w - learningRate * inv(Rxx) * L1 / Sw;
    %     w = w - learningRate * L1 / Sw;
    %     w =  ( X * tanh(y)')/IClen - mu1 *( X * ref')/IClen;
%     rt=zeros(IClen,IClen);
    r=zeros(1,IClen);   
    gdg2x=zeros(ICnum,IClen);
    for k=1:IClen
        yk = circshift(y',-k);
        yk(end-k+1:end)=0;
%         yk=[y(k+1:end) zeros(1,k)]';
%         rt(:,k)=yk;
        r(k)=y*yk;
        gdg2x(:,k)=X*yk;
    end

    gdg2=-2*gdg2x*r'/IClen;
%     gdg2=-2*X*rt*r'/IClen;
    w =  ( X * tanh(y)')/IClen - mu1 *( X * ref')/IClen- mu2 *gdg2;
    w = w/norm(w);
    
 
    % output at current iteration
    y = w' * X;
    
    %     thr = threshold;
    g1 = thr1 - mean(y*ref');
    if g1>0
        thr1 = thr1 *0.95;
    end
    
    g2=thr2 - mean(power(r,2));
    if g2>0
        thr1 = thr1 *1.05;
    end
    
    % update of the parameter mu1
    %  g = mean( (y-ref).^2 ) - thr;    % corresponds to the inequality constraint
    mu1 = max(0, mu1 + gamma1 * g1);
    mu2 = max(0, mu2 + gamma2 * g2);
    
    % update of the parameter lambda
    %     h = mean(y.^2) - 1;                    % corresponds to the equality constraint
    %     lambda = lambda + gamma * h;
    
    
    % decide whether the algorithm has converged or not
    wchange = abs(abs(w'*oldw)-1);
    fprintf('No.%d iteration: change in w is %g\n',loop, wchange);
    if wchange < OverValue
        fprintf('Converged after %d iteration\n',loop);
        flag = 0;
    end
    
    if loop >= maxIter
        fprintf('After %d iteration, still cannot convergent.\n',loop);
        flag = 0;
    end
    
    oldw = w;
    loop = loop + 1;
    
    plot(y)
end

% output
y = w'* X;
g1
g2
figure
plot(y)
fprintf('End of cICA algorithm !\n');
